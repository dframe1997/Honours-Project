#Functions to detect periodic sentences
from Canary import SentenceFormat, helperFunctions
import nltk
from nltk.tokenize import sent_tokenize
from nltk.tree import Tree
import sys

sys.path.insert(0, '../../../../perkeleyparser')

from BerkeleyParser import parser

nltk.data.path.append(r"D:\Users\David\Documents\Work\University\Year 4\Honours\NLTK")

berkeleyPath = "../../../../berkeleyparser/berkeleyParser-1.7.jar"
grammarPath = "../../../../berkeleyparser/eng_sm6.gr"

prepositionSearchDepth = 3 #2(60%) #3(70%) #4(57.81%) #5(51.39%) #7(24.8%)
depthIncreaseThreshold = 10

def startingWords(sentence, debug):
    for index in range(prepositionSearchDepth):
        if sentence.tagged[index][1] == "IN": #IN represents prepositions or 'subordinating conjunctions' which are often found at the start of a subordinate clause and therefore a periodic sentence
            return True
    return False       

def treeStructure(sentence, debug):
    #Based on characterizing stylistic elements
    p = parser(berkeleyPath, grammarPath)
    treeStringWBrackets = p.parse(sentence.text)
    treeString = treeStringWBrackets[1:len(treeStringWBrackets)-1]
    p.terminate() #End the parser process to save memory
    tree = Tree.fromstring(treeString) #Turn the string generated by the parser into a tree object
    #topOfTree = tree[0:treeSearchDepth] #It's not a string - need a new way to get the top layers of tree
    #tree.draw()
    for subtree in tree.subtrees():
        h = subtree.height()
        if h == tree.height()-1: #tree height is the number of subtrees under it, so the top few layers will have the greatest height #Possibly dynamic based on length of sentence?
            if subtree.label() != "VP":
                #if any(x.label() == "S" for x in subtree.subtrees()) or any(x.label() == "SBAR" for x in subtree.subtrees()): #Should it be topOfTree or node (aka search the subtree topped by node)?
                    #return True
                if any(x.label() == "S" for x in subtree.subtrees()) or any(x.label() == "SBAR" for x in subtree.subtrees()):
                    #halfSentence = sentence.text[:len(sentence.text) // 2]
                    #subordinateWord = subtree.leaves()[0]
                    #if subordinateWord in halfSentence:
                    return True
            #else:
                #if any(x.label() == "S" for x in subtree.subtrees()) or any(x.label() == "SBAR" for x in subtree.subtrees()):
                    #return Loose
                    # ONLY IMPLEMENT IF NEED TO DETECT LOOSE SENTENCES
    return False

def detectPeriodic(sentences, debug, checkArgument, natureOfSentences):
    score = 0
    numPeriodic = 0
    startingWordImpliesArgument = False
    treeStructureIsPeriodic = False
    for sentence in sentences:
        if(debug == True):
            print(sentence.text)
            print(sentence.tokens)
            print(sentence.tagged)
            print(sentence.entities)
        #sentence.entities.draw()
        if startingWords(sentence, debug):
            startingWordImpliesArgument = True
            if checkArgument:
                if treeStructure(sentence, debug):
                    treeStructureIsPeriodic = True
        elif treeStructure(sentence, debug):
            treeStructureIsPeriodic = True

        if startingWordImpliesArgument or treeStructureIsPeriodic:
            sentence.periodic = True
            numPeriodic += 1
            if natureOfSentences == "Periodic":
                score += 1
            print("'" + sentence.text + "'" + " is a periodic sentence.")
        else:
            sentence.periodic = False
            if natureOfSentences == "NotPeriodic":
                score += 1
            print("'" + sentence.text + "'" + " is not a periodic sentence.")
        
        if checkArgument and startingWordImpliesArgument and treeStructureIsPeriodic:
            sentence.argument = True

    if sentences.__len__() > 0: 
        score = (score/sentences.__len__())*100
    else:
        score = "N/A"
    return sentences, score, numPeriodic

